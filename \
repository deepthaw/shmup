#include <mikmod.h>
#include <stdio.h>
#include <stdlib.h>

#define STACK_SIZE 256

/* revised opcode structure
 * 6502 forever
 * bit[00:12] : opcode
 * bit[13:16] : addresing mode
*/

#define OPCODE 0xFFF;

typedef enum {
  IMM,
  MEM,
  MEMX,
  MEMY
} addrmode;

typedef enum {
  OP_ADD,
  OP_AND,
  OP_ASL,
  OP_BCC,
  OP_BCS,
  OP_BEQ,
  OP_BMI,
  OP_BNE,
  OP_BPL,
  OP_BVC,
  OP_BVS,
  OP_CLC,
  OP_CLV,
  OP_CMP,
  OP_CPX,
  OP_CPY,
  OP_DEC
} OpCode;

typedef enum { A, X, Y, C, V, Z, N, IP, SP, SX, SY, SF, SS, PX, PY, MEMO, NUMREGS } Register;

typedef enum { EV_GETPLAYERXY } Event;

typedef struct Self {
  int x, y;
  int speed;
  int frame;
  int playerx, playery;
} Self;

typedef struct Queue {
  int event;
  struct Queue *next;
} Queue;

typedef struct {
  int stack[STACK_SIZE];
  struct Queue *queue;
  int reg[NUMREGS];
  unsigned char *code;
  int mem[256];
} VM;

void init_vm(VM *vm, unsigned char *code) {
  vm->reg[SP] = -1;
  vm->code = code;
  vm->reg[IP] = 0;
  vm->queue = calloc(1, sizeof(struct Queue));
}

void push(VM *vm, int value) { vm->stack[++vm->reg[SP]] = value; }

int pop(VM *vm) { return vm->stack[vm->reg[SP]--]; }

int dequeue(VM *vm) {
  if (vm->queue != NULL) {
    int event = vm->queue->event;
    Queue *node = vm->queue;
    vm->queue = vm->queue->next;
    free(node);
    return event;
  }
  return 0;
}

void enqueue(VM *vm, int event) {
  Queue *node = vm->queue;
  while (node->next) {
    node = node->next;
  }
  node->next = calloc(1, sizeof(Queue));
  node->next->event = event;
  node->next->next = NULL;
}

#define immmode() vm->reg[IP]++
#define adrmode() (mem[(vm->[ip]++) + (*aregs[mode])])

void execute(VM *vm) {
  int running = 1;
  int *mem = vm->mem;
  int *reg = vm->reg;
  int zero = 0;
  int *aregs[3] = { &zero, &reg[X], &reg[Y] };
  while (running) {
    int data = vm->code[vm->reg[IP]++];
    OpCode op = data & OPCODE;
    addrmode mode = data << 12;
    switch (op) {
      case OP_ADD: {
        switch (mode) {
          case IMM:  { reg[A] = reg[A] + immmode(); break; }
          case MEM:
          case MEMX:
          case MEMY: { reg[A] = reg[A] + mem[vm->[ip]++ + *aregs[mode]]; break; }
        }
        break;
      }
      case OP_AND: {
        switch (mode) {
          case IMM : { reg[A] = reg[A] && immmode(); break; }
          case MEM :
          case MEMX:
          case MEMY: { reg[A] = reg[A] && adrmode(); break; }
        }
        break;
      }
      }
      case OP_ASL: {
        switch (mode) {
          case IMM :
          case MEM :
          case MEMX: { reg[A] = mem[vm->reg[IP]++ + *aregs[mode]] << 1; break; }




      /*

      case OP_LD: {
      break;
    }
    case OP_ST: {
      break;
    }
    case OP_POP: { // POPA POPB
      if (operand == ONE_OP) reg[reg1] = pop(vm);
      break;
    }
    case OP_PUSH: { // PUSHA PUSHB PUSH MEM
      if (operand == ONE_OP) push(vm, reg[reg1]);
      if (operand == MEM_OP) push(vm, mem[vm->ip++]);    
      break;
    }
    case OP_ADD: { // ADDA REG1 REG2
      if (operand == IMM_OP) reg[A] = reg[A] + vm->ip++;
      if (operand == ONE_OP) reg[A] = reg[A] + reg1;
      if (operand == TWO_OP) reg[A] = reg1 + reg2;
      if (operand == MEM_OP) reg[A] = reg[A] + mem[vm->ip++];
      break;
    }
    case OP_SUB: {
      if (operand == IMM_OP) reg[A] = reg[A] - vm->ip++;
      if (operand == ONE_OP) reg[A] = reg[A] - reg1;
      if (operand == TWO_OP) reg[A] = reg1 - reg2;
      if (operand == MEM_OP) reg[A] = reg[A] - mem[vm->ip++];
      break;
    }
    case OP_MUL: {
      if (operand == IMM_OP) reg[A] = reg[A] * vm->ip++;
      if (operand == ONE_OP) reg[A] = reg[A] * reg1;
      if (operand == TWO_OP) reg[A] = reg1 * reg2;
      if (operand == MEM_OP) reg[A] = reg[A] * mem[vm->ip++];
      break;
    }
    case OP_DIV: {
      if (operand == IMM_OP) reg[reg1] = reg[reg1] / vm->ip++; // DIVA #NUM
      if (operand == ONE_OP) reg[reg1] = reg[reg1] / reg[reg2]; // DIVA B
      if (operand == TWO_OP) reg[A] = reg[reg1] / reg[reg2]; // DIVA B, C 
      if (operand == MEM_OP) reg[A] = reg[reg1] / mem[vm->ip++]; // DIVA B,$MEM
      break;
    }
    case OP_CMP: {
      if (operand == ONE_OP) {
        if (reg[reg1] > reg[reg2]) reg[reg1] = -1;
        else if (reg[reg1] < reg[reg2]) reg[reg1] = 1;
        else reg[reg1] = 0;
      }
      break;
    }
    case OP_ENQUEUE: {
      int event = pop(vm);
      enqueue(vm, event);
      break;
    }
    case OP_DEQUEUE: {
      push(vm, dequeue(vm));
      break;
    }
    case OP_HALT: {
      running = 0;
      break;
    }
    */
    }
  }
}

int main(int argc, char *args[]) {
  VM vm;
  execute(&vm);
  printf("Result: %d\n", pop(&vm));
  return 0;
}
